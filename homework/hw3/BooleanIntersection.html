<!DOCTYPE html>
<html>
<html lang="en" ng-app="computerGraphics">
<head>
  <meta charset="utf-8">
  <!--<meta Content-Type="text/csv"/>-->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=1.0, minimum-scale=1.0, maximum-scale=1.0">
  <meta name="description" content="This website holds the homework of Computer Graphics">
  <meta name="author" content="Youlong Li">
  <title>Computer Graphics</title>
  <!-- Bootstrap core CSS -->
  <link href="../../bower_components/bootstrap/dist/css/bootstrap.css" rel="stylesheet">
  <!-- Custom styles -->
  <link href="../../app.css" rel="stylesheet">
  <!-- JS Files -->
  <script src="../../bower_components/jquery/dist/jquery.js"></script>
  <script src="../../bower_components/bootstrap/dist/js/bootstrap.js"></script>
  <script src="../lib/lib1.js"></script>
</head>
<body ng-cloak ng-controller="mainCtrl">

<h1 id="title">Computer Graphics</h1>
<h2 id="author">Youlong Li</h2>

<div class="button-panel">
  <a href="../../Contents.html" class="btn btn-primary">Contents</a>

  <div class="btn-group">
    <button type="button" class="btn btn-primary dropdown-toggle" data-toggle="dropdown" aria-expanded="false">
      HW3<span class="caret"></span>
    </button>
    <ul class="dropdown-menu" role="menu">
      <li><a href="../hw3/Matrix.html">Matrix</a></li>
      <li><a href="../hw3/Bounce.html">Bounce</a></li>
      <li class="divider"></li>
      <li><a href="../hw3/BlinnModel.html">Blinn</a></li>
      <li><a href="../hw3/PhongModel.html">Phong</a></li>
      <li><a href="../hw3/Reflection.html">Reflection</a></li>
      <li><a href="../hw3/BooleanIntersection.html">BooleanIntersection</a></li>
    </ul>
  </div>
</div>

<hr/>

<div id="show-box">
  <h1>Boolean Intersection</h1>

  <body bgcolor=black>
  <td><canvas id='canvas1' width=600 height=600></canvas></td>
  </body>

  <script id='my_vertex_shader' type='x-shader/x-vertex'>
   attribute vec3 aPosition;
   varying   vec3 vPosition;
   void main() {
      gl_Position = vec4(aPosition, 1.0);
      vPosition = aPosition;
   }
</script>

  <script id='my_fragment_shader' type='x-shader/x-fragment'>
  precision mediump float;
  uniform float uTime;
  uniform vec3  uCursor;
  varying vec3  vPosition;

  const int numOfSpheres = 3;
  vec4 sphere[numOfSpheres];
  vec3 material[numOfSpheres];

  const int numOfLights = 1;
  vec3 Lrgb[numOfLights];
  vec3 Ldir[numOfLights];

  const float PI = 3.1415926535897932384626433832795;
  const float NOT_FOUND = 1000.;

  // All colors come from: http://nipponcolors.com
  vec3 colors[10];
  const vec3 COLOR_KARAKURENAI = vec3(208. / 255., 16. / 255., 76. / 255.);
  const vec3 COLOR_HANAASAGI = vec3(30. / 255., 136. / 255., 168. / 255.);
  const vec3 COLOR_NAE = vec3(134. / 255., 193. / 255., 102. / 255.);
  const vec3 COLOR_USUKOH = vec3(235. / 255., 180. / 255., 113. / 255.);
  const vec3 COLOR_SHION = vec3(143. / 255., 119. / 255., 181. / 255.);
  const vec3 COLOR_AONIBI = vec3(83. / 255., 89. / 255., 83. / 255.);
  const vec3 COLOR_RURIKON = vec3(11. / 255., 52. / 255., 110. / 255.);
  const vec3 COLOR_SAKURA = vec3(254. / 255., 223. / 255., 225. / 255.);
  const vec3 COLOR_KIHADA = vec3(251. / 255., 226. / 255., 81. / 255.);
  const vec3 COLOR_SENSAICHA = vec3(77. / 255., 81. / 255., 57. / 255.);
  const int numOfColors = 10;

  vec4 foundSphere;
  vec3 foundMaterial;
  float foundT;

  void setColors() {
    colors[0] = COLOR_KARAKURENAI;
    colors[1] = COLOR_HANAASAGI;
    colors[2] = COLOR_NAE;
    colors[3] = COLOR_USUKOH;
    colors[4] = COLOR_SHION;
    colors[5] = COLOR_AONIBI;
    colors[6] = COLOR_RURIKON;
    colors[7] = COLOR_SAKURA;
    colors[8] = COLOR_KIHADA;
    colors[9] = COLOR_SENSAICHA;
  }

  void setLights(vec2 c) {
    Lrgb[0] = vec3(1., 1., 1.);
    //Lrgb[1] = vec3(0., 0., 0.);
    //Lrgb[2] = vec3(1., 1., 1.);
    //Lrgb[3] = vec3(0., 0., 0.);

    Ldir[0] = vec3(c.x, c.y, 1. - 2. * dot(c, c));
    //Ldir[1] = vec3(-1., 1., 1. - 2. * dot(c, c));
    //Ldir[2] = vec3(-1., -1., 1. - 2. * dot(c, c));
    //Ldir[3] = vec3(1., -1., 1. - 2. * dot(c, c));

    for (int i = 0; i < numOfLights; i++) {
      Ldir[i] = normalize(Ldir[i]);
    }
  }

  void setMaterial() {
    for (int i = 0; i < numOfSpheres; i++) {
      material[i] = colors[int(mod(float(i), float(numOfColors)))];
    }
  }

  void setSphereMovements() {
    float move = 2. + sin(uTime);
    sphere[0] = vec4(0., move * .2, -2.3, .40);
    sphere[1] = vec4(move * sqrt(2. * pow(.2, 2.)), -move * sqrt(2. * pow(.2, 2.)), -2.3, .40);
    sphere[2] = vec4(-move * sqrt(2. * pow(.2, 2.)), -move * sqrt(2. * pow(.2, 2.)), -2.3, .40);
  }

  // Compute intersection of a ray with a sphere, if any. Store the sphere,
  // material and t for later usage.
  // If there is no intersection, return default t which is 1000.
  void findSphere(vec3 V, vec3 W) {
    foundT = NOT_FOUND;

    for (int i = 0; i < numOfSpheres; i++) {
      float B = 2. * dot(W, V - sphere[i].xyz);
      float C = dot(V - sphere[i].xyz, V - sphere[i].xyz) - pow(sphere[i].w, 2.);
      float D = pow(B, 2.) - 4. * C;

      if (D < 0.) {
        continue;
      } else {
        float t = (-B - sqrt(D)) / 2.;

        if (t >= 0. && t < foundT) {
          foundT = t;
          foundSphere = sphere[i];
          foundMaterial = material[i];
        }
      }
    }
  }

  void findIntersection(vec3 V, vec3 W) {
    foundT = NOT_FOUND;
    float tIn[numOfSpheres];
    float tOut[numOfSpheres];

    for (int i = 0; i < numOfSpheres; i++) {
      float B = 2. * dot(W, V - sphere[i].xyz);
      float C = dot(V - sphere[i].xyz, V - sphere[i].xyz) - pow(sphere[i].w, 2.);
      float D = pow(B, 2.) - 4. * C;

      if (D < 0.) {
        tIn[i] = NOT_FOUND;
        tOut[i] = NOT_FOUND;
      } else {
        if ((-B - sqrt(D)) / 2. >= 0.) {
          tIn[i] = (-B - sqrt(D)) / 2.;
          tOut[i] = (-B + sqrt(D)) / 2.;
        }
      }
    }

    for (int a = 0; a < numOfSpheres; a++) {
      for (int b = 0; b < numOfSpheres; b++) {
        if (a == b) {
          continue;
        }
        if (tIn[a] != NOT_FOUND && tIn[a] != NOT_FOUND) {
          float maxTIn = max(tIn[a], tIn[b]);
          float minTOut = min(tOut[a], tOut[b]);
          if (maxTIn < minTOut) {
            if (maxTIn == tIn[a]) {
              foundT = tIn[a];
              foundSphere = sphere[a];
              foundMaterial = material[a];
            } else if (maxTIn == tIn[b]) {
              foundT = tIn[b];
              foundSphere = sphere[b];
              foundMaterial = material[b];
            }
          }
        }
      }
    }
  }

  // Diffusely shade a sphere.
  //    point is the x,y,z position of the surface point.
  //    sphere is the x,y,z,r definition of the sphere.
  //    material is the r,g,b color of the sphere.

  vec3 shadeSphere(vec3 point, vec4 sphere, vec3 material, vec3 W) {
    vec3 N = normalize((point - sphere.xyz) / sphere.w);

    vec3 ambient = material / 5.;   // rgb
    vec3 diffuse = material / .8;   // rgb

    vec3 color = ambient;

    for (int i = 0; i < numOfLights; i++) {
      findIntersection(point + .01 * Ldir[i], Ldir[i]);

      if (foundT == NOT_FOUND) {
        vec3 H = (N + Ldir[i]) * .5;
        color += Lrgb[i] * (diffuse * max(0., dot(N, Ldir[i])) + material * pow(max(0., dot(N, H)), 75.));
      }
    }

    return color;
  }

  void main(void) {
    vec2 c = uCursor.xy;

    setLights(c);

    setColors();

    // YOU NEED TO COMPUTE V AND W TO CREATE THE RAY FOR THIS PIXEL,
    // USING vPosition.x AND vPosition.y.

    vec3 V = vec3(0., 0., 0.);
    vec3 W = normalize(vec3(vPosition.x, vPosition.y, -2.));

    // YOU NEED TO SET x,y,z AND r FOR sphere.
    setSphereMovements();

    // YOU NEED TO SET r,g,b FOR material.
    setMaterial();

    vec3 color = vec3(0., 0., 0.);

    if (sin(uTime) > -.57) {
      findSphere(V, W);
    } else {
      findIntersection(V, W);
    }

    if (foundT == NOT_FOUND) {
      gl_FragColor = vec4(sqrt(color), 1.); // Do Gamma correction.
      return;
    }

    color = shadeSphere(V + foundT * W, foundSphere, foundMaterial, W);

    gl_FragColor = vec4(sqrt(color), 1.); // Do Gamma correction.
  }
</script>
</div>

<script>
  start_gl('canvas1', document.getElementById('my_vertex_shader').innerHTML,
      document.getElementById('my_fragment_shader').innerHTML);
</script>

</body>
</html>